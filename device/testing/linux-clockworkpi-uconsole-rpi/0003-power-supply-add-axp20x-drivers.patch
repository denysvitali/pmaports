From beaa344b0319431774f59f358557edec19b98660 Mon Sep 17 00:00:00 2001
From: Antoine Martin <dev@ayakael.net>
Date: Fri, 30 May 2025 15:08:17 -0400
Subject: [PATCH 3/5] power/supply: add axp20x drivers


diff --git a/drivers/power/supply/axp20x_ac_power.c b/drivers/power/supply/axp20x_ac_power.c
index e5733cb9e..5be12e696 100644
--- a/drivers/power/supply/axp20x_ac_power.c
+++ b/drivers/power/supply/axp20x_ac_power.c
@@ -52,6 +52,9 @@ static irqreturn_t axp20x_ac_power_irq(int irq, void *devid)
 {
 	struct axp20x_ac_power *power = devid;
 
+	regmap_update_bits(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, 0x03, 0x00);
+	regmap_update_bits(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, 0x03, 0x03);
+
 	power_supply_changed(power->supply);
 
 	return IRQ_HANDLED;
diff --git a/drivers/power/supply/axp20x_battery.c b/drivers/power/supply/axp20x_battery.c
index 57eba1ddb..a9437d8cc 100644
--- a/drivers/power/supply/axp20x_battery.c
+++ b/drivers/power/supply/axp20x_battery.c
@@ -32,79 +32,83 @@
 #include <linux/iio/consumer.h>
 #include <linux/mfd/axp20x.h>
 
-#define AXP20X_PWR_STATUS_BAT_CHARGING	BIT(2)
-#define AXP717_PWR_STATUS_MASK		GENMASK(6, 5)
-#define AXP717_PWR_STATUS_BAT_STANDBY	0
-#define AXP717_PWR_STATUS_BAT_CHRG	1
-#define AXP717_PWR_STATUS_BAT_DISCHRG	2
+#define AXP20X_PWR_STATUS_BAT_CHARGING BIT(2)
+#define AXP717_PWR_STATUS_MASK GENMASK(6, 5)
+#define AXP717_PWR_STATUS_BAT_STANDBY 0
+#define AXP717_PWR_STATUS_BAT_CHRG 1
+#define AXP717_PWR_STATUS_BAT_DISCHRG 2
 
-#define AXP20X_PWR_OP_BATT_PRESENT	BIT(5)
-#define AXP20X_PWR_OP_BATT_ACTIVATED	BIT(3)
-#define AXP717_PWR_OP_BATT_PRESENT	BIT(3)
+#define AXP20X_PWR_OP_BATT_PRESENT BIT(5)
+#define AXP20X_PWR_OP_BATT_ACTIVATED BIT(3)
+#define AXP717_PWR_OP_BATT_PRESENT BIT(3)
 
-#define AXP717_BATT_PMU_FAULT_MASK	GENMASK(2, 0)
-#define AXP717_BATT_UVLO_2_5V		BIT(2)
-#define AXP717_BATT_OVER_TEMP		BIT(1)
-#define AXP717_BATT_UNDER_TEMP		BIT(0)
+#define AXP717_BATT_PMU_FAULT_MASK GENMASK(2, 0)
+#define AXP717_BATT_UVLO_2_5V BIT(2)
+#define AXP717_BATT_OVER_TEMP BIT(1)
+#define AXP717_BATT_UNDER_TEMP BIT(0)
 
-#define AXP209_FG_PERCENT		GENMASK(6, 0)
-#define AXP22X_FG_VALID			BIT(7)
+#define AXP209_FG_PERCENT GENMASK(6, 0)
+#define AXP22X_FG_VALID BIT(7)
 
-#define AXP20X_CHRG_CTRL1_ENABLE	BIT(7)
-#define AXP20X_CHRG_CTRL1_TGT_VOLT	GENMASK(6, 5)
-#define AXP20X_CHRG_CTRL1_TGT_4_1V	(0 << 5)
-#define AXP20X_CHRG_CTRL1_TGT_4_15V	(1 << 5)
-#define AXP20X_CHRG_CTRL1_TGT_4_2V	(2 << 5)
-#define AXP20X_CHRG_CTRL1_TGT_4_36V	(3 << 5)
+#define AXP20X_CHRG_CTRL1_ENABLE BIT(7)
+#define AXP20X_CHRG_CTRL1_TGT_VOLT GENMASK(6, 5)
+#define AXP20X_CHRG_CTRL1_TGT_4_1V (0 << 5)
+#define AXP20X_CHRG_CTRL1_TGT_4_15V (1 << 5)
+#define AXP20X_CHRG_CTRL1_TGT_4_2V (2 << 5)
+#define AXP20X_CHRG_CTRL1_TGT_4_36V (3 << 5)
 
-#define AXP22X_CHRG_CTRL1_TGT_4_22V	(1 << 5)
-#define AXP22X_CHRG_CTRL1_TGT_4_24V	(3 << 5)
+#define AXP22X_CHRG_CTRL1_TGT_4_22V (1 << 5)
+#define AXP22X_CHRG_CTRL1_TGT_4_24V (3 << 5)
 
-#define AXP717_CHRG_ENABLE		BIT(1)
-#define AXP717_CHRG_CV_VOLT_MASK	GENMASK(2, 0)
-#define AXP717_CHRG_CV_4_0V		0
-#define AXP717_CHRG_CV_4_1V		1
-#define AXP717_CHRG_CV_4_2V		2
-#define AXP717_CHRG_CV_4_35V		3
-#define AXP717_CHRG_CV_4_4V		4
+#define AXP717_CHRG_ENABLE BIT(1)
+#define AXP717_CHRG_CV_VOLT_MASK GENMASK(2, 0)
+#define AXP717_CHRG_CV_4_0V 0
+#define AXP717_CHRG_CV_4_1V 1
+#define AXP717_CHRG_CV_4_2V 2
+#define AXP717_CHRG_CV_4_35V 3
+#define AXP717_CHRG_CV_4_4V 4
 /* Values 5 and 6 reserved. */
-#define AXP717_CHRG_CV_5_0V		7
+#define AXP717_CHRG_CV_5_0V 7
 
-#define AXP813_CHRG_CTRL1_TGT_4_35V	(3 << 5)
+#define AXP813_CHRG_CTRL1_TGT_4_35V (3 << 5)
 
-#define AXP20X_CHRG_CTRL1_TGT_CURR	GENMASK(3, 0)
-#define AXP717_ICC_CHARGER_LIM_MASK	GENMASK(5, 0)
+#define AXP20X_CHRG_CTRL1_TGT_CURR GENMASK(3, 0)
+#define AXP717_ICC_CHARGER_LIM_MASK GENMASK(5, 0)
 
-#define AXP717_ITERM_CHG_LIM_MASK	GENMASK(3, 0)
-#define AXP717_ITERM_CC_STEP		64000
+#define AXP717_ITERM_CHG_LIM_MASK GENMASK(3, 0)
+#define AXP717_ITERM_CC_STEP 64000
 
-#define AXP20X_V_OFF_MASK		GENMASK(2, 0)
-#define AXP717_V_OFF_MASK		GENMASK(6, 4)
+#define AXP20X_V_OFF_MASK GENMASK(2, 0)
+#define AXP717_V_OFF_MASK GENMASK(6, 4)
 
-#define AXP717_BAT_VMIN_MIN_UV		2600000
-#define AXP717_BAT_VMIN_MAX_UV		3300000
-#define AXP717_BAT_VMIN_STEP		100000
-#define AXP717_BAT_CV_MIN_UV		4000000
-#define AXP717_BAT_CV_MAX_UV		5000000
-#define AXP717_BAT_CC_MIN_UA		0
-#define AXP717_BAT_CC_MAX_UA		3008000
+#define AXP228_FULL_CAPACITY_CALIBRATE_EN BIT(5)
+#define AXP228_CAPACITY_CALIBRATE BIT(4)
+#define AXP228_CALIBRATE_MASK (BIT(4) | BIT(5))
+
+#define AXP717_BAT_VMIN_MIN_UV 2600000
+#define AXP717_BAT_VMIN_MAX_UV 3300000
+#define AXP717_BAT_VMIN_STEP 100000
+#define AXP717_BAT_CV_MIN_UV 4000000
+#define AXP717_BAT_CV_MAX_UV 5000000
+#define AXP717_BAT_CC_MIN_UA 0
+#define AXP717_BAT_CC_MAX_UA 3008000
 
 struct axp20x_batt_ps;
 
 struct axp_data {
-	int		ccc_scale;
-	int		ccc_offset;
-	unsigned int	ccc_reg;
-	unsigned int	ccc_mask;
-	bool		has_fg_valid;
-	const struct	power_supply_desc *bat_ps_desc;
-	int	(*get_max_voltage)(struct axp20x_batt_ps *batt, int *val);
-	int	(*set_max_voltage)(struct axp20x_batt_ps *batt, int val);
-	int	(*cfg_iio_chan)(struct platform_device *pdev,
-				struct axp20x_batt_ps *axp_batt);
-	void	(*set_bat_info)(struct platform_device *pdev,
-				struct axp20x_batt_ps *axp_batt,
-				struct power_supply_battery_info *info);
+	int ccc_scale;
+	int ccc_offset;
+	unsigned int ccc_reg;
+	unsigned int ccc_mask;
+	bool has_fg_valid;
+	const struct power_supply_desc *bat_ps_desc;
+	int (*get_max_voltage)(struct axp20x_batt_ps *batt, int *val);
+	int (*set_max_voltage)(struct axp20x_batt_ps *batt, int val);
+	int (*cfg_iio_chan)(struct platform_device *pdev,
+			    struct axp20x_batt_ps *axp_batt);
+	void (*set_bat_info)(struct platform_device *pdev,
+			     struct axp20x_batt_ps *axp_batt,
+			     struct power_supply_battery_info *info);
 };
 
 struct axp20x_batt_ps {
@@ -116,7 +120,10 @@ struct axp20x_batt_ps {
 	struct iio_channel *batt_v;
 	/* Maximum constant charge current */
 	unsigned int max_ccc;
-	const struct axp_data	*data;
+	int energy_full_design;
+	int current_now;
+	int voltage_now;
+	const struct axp_data *data;
 };
 
 static int axp20x_battery_get_max_voltage(struct axp20x_batt_ps *axp20x_batt,
@@ -265,7 +272,7 @@ static int axp717_get_constant_charge_current(struct axp20x_batt_ps *axp,
 		return ret;
 
 	*val = FIELD_GET(AXP717_ICC_CHARGER_LIM_MASK, *val) *
-		axp->data->ccc_scale;
+	       axp->data->ccc_scale;
 
 	return 0;
 }
@@ -355,9 +362,11 @@ static int axp20x_battery_get_prop(struct power_supply *psy,
 			return ret;
 
 		if (reg & AXP20X_PWR_STATUS_BAT_CHARGING) {
-			ret = iio_read_channel_processed(axp20x_batt->batt_chrg_i, &val->intval);
+			ret = iio_read_channel_processed(
+				axp20x_batt->batt_chrg_i, &val->intval);
 		} else {
-			ret = iio_read_channel_processed(axp20x_batt->batt_dischrg_i, &val1);
+			ret = iio_read_channel_processed(
+				axp20x_batt->batt_dischrg_i, &val1);
 			val->intval = -val1;
 		}
 		if (ret)
@@ -365,6 +374,8 @@ static int axp20x_battery_get_prop(struct power_supply *psy,
 
 		/* IIO framework gives mA but Power Supply framework gives uA */
 		val->intval *= 1000;
+		axp20x_batt->current_now = val->intval;
+
 		break;
 
 	case POWER_SUPPLY_PROP_CAPACITY:
@@ -413,6 +424,63 @@ static int axp20x_battery_get_prop(struct power_supply *psy,
 
 		/* IIO framework gives mV but Power Supply framework gives uV */
 		val->intval *= 1000;
+		axp20x_batt->current_now = val->intval;
+
+		break;
+
+	case POWER_SUPPLY_PROP_ENERGY_FULL:
+	case POWER_SUPPLY_PROP_ENERGY_NOW:
+	case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		/* When no battery is present, return 0 */
+		ret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,
+				  &reg);
+		if (ret)
+			return ret;
+
+		if (!(reg & AXP20X_PWR_OP_BATT_PRESENT)) {
+			val->intval = 0;
+			return 0;
+		}
+
+		if (psp == POWER_SUPPLY_PROP_ENERGY_FULL) {
+			// TODO
+			val->intval = axp20x_batt->energy_full_design;
+			return 0;
+		}
+
+		if (psp == POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN) {
+			val->intval = axp20x_batt->energy_full_design;
+			return 0;
+		}
+
+		ret = regmap_read(axp20x_batt->regmap, AXP20X_FG_RES, &reg);
+		if (ret)
+			return ret;
+
+		if (axp20x_batt->data->has_fg_valid && !(reg & AXP22X_FG_VALID))
+			return -EINVAL;
+
+		val1 = reg & AXP209_FG_PERCENT;
+		val1 = max(min(val1, 100), 0);
+		val->intval =
+			(val1 *
+			 ((long long int)axp20x_batt->energy_full_design)) /
+			100;
+		break;
+
+	case POWER_SUPPLY_PROP_CALIBRATE:
+		// report both calibrate enable flag and calibration status
+		ret = regmap_read(axp20x_batt->regmap, AXP20X_CC_CTRL, &reg);
+		if (ret)
+			return ret;
+		val1 = reg & AXP228_CALIBRATE_MASK;
+		val->intval = val1;
+		break;
+
+	case POWER_SUPPLY_PROP_POWER_NOW:
+		val->intval = (axp20x_batt->voltage_now / 10000) *
+			      axp20x_batt->current_now;
+		val->intval = val->intval / 100; // uW
 		break;
 
 	default:
@@ -471,8 +539,7 @@ static int axp717_battery_get_prop(struct power_supply *psy,
 	 * listed as POR.
 	 */
 	case POWER_SUPPLY_PROP_HEALTH:
-		ret = regmap_read(axp20x_batt->regmap, AXP717_PMU_FAULT,
-				  &reg);
+		ret = regmap_read(axp20x_batt->regmap, AXP717_PMU_FAULT, &reg);
 		if (ret)
 			return ret;
 
@@ -520,7 +587,8 @@ static int axp717_battery_get_prop(struct power_supply *psy,
 		 * observation it's assumed to be somewhere around
 		 * 450ma. I will leave the value raw for now.
 		 */
-		ret = iio_read_channel_processed(axp20x_batt->batt_chrg_i, &val->intval);
+		ret = iio_read_channel_processed(axp20x_batt->batt_chrg_i,
+						 &val->intval);
 		if (ret)
 			return ret;
 		/* IIO framework gives mA but Power Supply framework gives uA */
@@ -536,8 +604,8 @@ static int axp717_battery_get_prop(struct power_supply *psy,
 		if (!FIELD_GET(AXP717_PWR_OP_BATT_PRESENT, reg))
 			return -ENODEV;
 
-		ret = regmap_read(axp20x_batt->regmap,
-				  AXP717_BATT_PERCENT_DATA, &reg);
+		ret = regmap_read(axp20x_batt->regmap, AXP717_BATT_PERCENT_DATA,
+				  &reg);
 		if (ret)
 			return ret;
 
@@ -553,13 +621,13 @@ static int axp717_battery_get_prop(struct power_supply *psy,
 							  &val->intval);
 
 	case POWER_SUPPLY_PROP_VOLTAGE_MIN:
-		ret = regmap_read(axp20x_batt->regmap,
-				  AXP717_VSYS_V_POWEROFF, &reg);
+		ret = regmap_read(axp20x_batt->regmap, AXP717_VSYS_V_POWEROFF,
+				  &reg);
 		if (ret)
 			return ret;
 
-		val->intval = AXP717_BAT_VMIN_MIN_UV + AXP717_BAT_VMIN_STEP *
-			(reg & AXP717_V_OFF_MASK);
+		val->intval = AXP717_BAT_VMIN_MIN_UV +
+			      AXP717_BAT_VMIN_STEP * (reg & AXP717_V_OFF_MASK);
 		return 0;
 
 	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
@@ -573,12 +641,13 @@ static int axp717_battery_get_prop(struct power_supply *psy,
 		return 0;
 
 	case POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
-		ret = regmap_read(axp20x_batt->regmap,
-				  AXP717_ITERM_CHG_SET, &reg);
+		ret = regmap_read(axp20x_batt->regmap, AXP717_ITERM_CHG_SET,
+				  &reg);
 		if (ret)
 			return ret;
 
-		val->intval = (reg & AXP717_ITERM_CHG_LIM_MASK) * AXP717_ITERM_CC_STEP;
+		val->intval = (reg & AXP717_ITERM_CHG_LIM_MASK) *
+			      AXP717_ITERM_CC_STEP;
 		return 0;
 
 	default:
@@ -666,8 +735,7 @@ static int axp717_battery_set_max_voltage(struct axp20x_batt_ps *axp20x_batt,
 		return -EINVAL;
 	}
 
-	return regmap_update_bits(axp20x_batt->regmap,
-				  AXP717_CV_CHG_SET,
+	return regmap_update_bits(axp20x_batt->regmap, AXP717_CV_CHG_SET,
 				  AXP717_CHRG_CV_VOLT_MASK, val);
 }
 
@@ -678,7 +746,7 @@ static int axp20x_set_constant_charge_current(struct axp20x_batt_ps *axp_batt,
 		return -EINVAL;
 
 	charge_current = (charge_current - axp_batt->data->ccc_offset) /
-		axp_batt->data->ccc_scale;
+			 axp_batt->data->ccc_scale;
 
 	if (charge_current > AXP20X_CHRG_CTRL1_TGT_CURR || charge_current < 0)
 		return -EINVAL;
@@ -698,8 +766,7 @@ static int axp717_set_constant_charge_current(struct axp20x_batt_ps *axp,
 	if (charge_current > AXP717_BAT_CC_MAX_UA || charge_current < 0)
 		return -EINVAL;
 
-	val = (charge_current - axp->data->ccc_offset) /
-		axp->data->ccc_scale;
+	val = (charge_current - axp->data->ccc_offset) / axp->data->ccc_scale;
 
 	return regmap_update_bits(axp->regmap, AXP717_ICC_CHG_SET,
 				  AXP717_ICC_CHARGER_LIM_MASK, val);
@@ -710,18 +777,19 @@ static int axp20x_set_max_constant_charge_current(struct axp20x_batt_ps *axp,
 {
 	bool lower_max = false;
 
-	charge_current = (charge_current - axp->data->ccc_offset) /
-		axp->data->ccc_scale;
+	charge_current =
+		(charge_current - axp->data->ccc_offset) / axp->data->ccc_scale;
 
 	if (charge_current > AXP20X_CHRG_CTRL1_TGT_CURR || charge_current < 0)
 		return -EINVAL;
 
-	charge_current = charge_current * axp->data->ccc_scale +
-		axp->data->ccc_offset;
+	charge_current =
+		charge_current * axp->data->ccc_scale + axp->data->ccc_offset;
 
 	if (charge_current > axp->max_ccc)
-		dev_warn(axp->dev,
-			 "Setting max constant charge current higher than previously defined. Note that increasing the constant charge current may damage your battery.\n");
+		dev_warn(
+			axp->dev,
+			"Setting max constant charge current higher than previously defined. Note that increasing the constant charge current may damage your battery.\n");
 	else
 		lower_max = true;
 
@@ -752,13 +820,13 @@ static int axp20x_set_voltage_min_design(struct axp20x_batt_ps *axp_batt,
 static int axp717_set_voltage_min_design(struct axp20x_batt_ps *axp_batt,
 					 int min_voltage)
 {
-	int val1 = (min_voltage - AXP717_BAT_VMIN_MIN_UV) / AXP717_BAT_VMIN_STEP;
+	int val1 =
+		(min_voltage - AXP717_BAT_VMIN_MIN_UV) / AXP717_BAT_VMIN_STEP;
 
 	if (val1 < 0 || val1 > AXP717_V_OFF_MASK)
 		return -EINVAL;
 
-	return regmap_update_bits(axp_batt->regmap,
-				  AXP717_VSYS_V_POWEROFF,
+	return regmap_update_bits(axp_batt->regmap, AXP717_VSYS_V_POWEROFF,
 				  AXP717_V_OFF_MASK, val1);
 }
 
@@ -767,14 +835,26 @@ static int axp20x_battery_set_prop(struct power_supply *psy,
 				   const union power_supply_propval *val)
 {
 	struct axp20x_batt_ps *axp20x_batt = power_supply_get_drvdata(psy);
+	int val1;
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_VOLTAGE_MIN:
 		return axp20x_set_voltage_min_design(axp20x_batt, val->intval);
 
 	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
-		return axp20x_batt->data->set_max_voltage(axp20x_batt, val->intval);
-
+		return axp20x_batt->data->set_max_voltage(axp20x_batt,
+							  val->intval);
+	case POWER_SUPPLY_PROP_CALIBRATE:
+		if (val->intval) {
+			// enable calibrate
+			val1 = AXP228_FULL_CAPACITY_CALIBRATE_EN |
+			       AXP228_CAPACITY_CALIBRATE;
+		} else {
+			// disable calibrate
+			val1 = 0;
+		}
+		return regmap_update_bits(axp20x_batt->regmap, AXP20X_CC_CTRL,
+					  AXP228_CALIBRATE_MASK, val1);
 	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
 		return axp20x_set_constant_charge_current(axp20x_batt,
 							  val->intval);
@@ -784,13 +864,16 @@ static int axp20x_battery_set_prop(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_STATUS:
 		switch (val->intval) {
 		case POWER_SUPPLY_STATUS_CHARGING:
-			return regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL1,
-				AXP20X_CHRG_CTRL1_ENABLE, AXP20X_CHRG_CTRL1_ENABLE);
+			return regmap_update_bits(axp20x_batt->regmap,
+						  AXP20X_CHRG_CTRL1,
+						  AXP20X_CHRG_CTRL1_ENABLE,
+						  AXP20X_CHRG_CTRL1_ENABLE);
 
 		case POWER_SUPPLY_STATUS_DISCHARGING:
 		case POWER_SUPPLY_STATUS_NOT_CHARGING:
-			return regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL1,
-				AXP20X_CHRG_CTRL1_ENABLE, 0);
+			return regmap_update_bits(axp20x_batt->regmap,
+						  AXP20X_CHRG_CTRL1,
+						  AXP20X_CHRG_CTRL1_ENABLE, 0);
 		}
 		fallthrough;
 	default:
@@ -809,7 +892,8 @@ static int axp717_battery_set_prop(struct power_supply *psy,
 		return axp717_set_voltage_min_design(axp20x_batt, val->intval);
 
 	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
-		return axp20x_batt->data->set_max_voltage(axp20x_batt, val->intval);
+		return axp20x_batt->data->set_max_voltage(axp20x_batt,
+							  val->intval);
 
 	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
 		return axp717_set_constant_charge_current(axp20x_batt,
@@ -846,6 +930,11 @@ static enum power_supply_property axp20x_battery_props[] = {
 	POWER_SUPPLY_PROP_VOLTAGE_MAX,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN,
 	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_ENERGY_FULL,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CALIBRATE,
+	POWER_SUPPLY_PROP_POWER_NOW,
 };
 
 static enum power_supply_property axp717_battery_props[] = {
@@ -869,7 +958,8 @@ static int axp20x_battery_prop_writeable(struct power_supply *psy,
 	       psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||
 	       psp == POWER_SUPPLY_PROP_VOLTAGE_MAX ||
 	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT ||
-	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;
+	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX ||
+	       psp == POWER_SUPPLY_PROP_CALIBRATE;
 }
 
 static int axp717_battery_prop_writeable(struct power_supply *psy,
@@ -911,16 +1001,15 @@ static int axp209_bat_cfg_iio_channels(struct platform_device *pdev,
 		return PTR_ERR(axp_batt->batt_v);
 	}
 
-	axp_batt->batt_chrg_i = devm_iio_channel_get(&pdev->dev,
-							"batt_chrg_i");
+	axp_batt->batt_chrg_i = devm_iio_channel_get(&pdev->dev, "batt_chrg_i");
 	if (IS_ERR(axp_batt->batt_chrg_i)) {
 		if (PTR_ERR(axp_batt->batt_chrg_i) == -ENODEV)
 			return -EPROBE_DEFER;
 		return PTR_ERR(axp_batt->batt_chrg_i);
 	}
 
-	axp_batt->batt_dischrg_i = devm_iio_channel_get(&pdev->dev,
-							   "batt_dischrg_i");
+	axp_batt->batt_dischrg_i =
+		devm_iio_channel_get(&pdev->dev, "batt_dischrg_i");
 	if (IS_ERR(axp_batt->batt_dischrg_i)) {
 		if (PTR_ERR(axp_batt->batt_dischrg_i) == -ENODEV)
 			return -EPROBE_DEFER;
@@ -940,8 +1029,7 @@ static int axp717_bat_cfg_iio_channels(struct platform_device *pdev,
 		return PTR_ERR(axp_batt->batt_v);
 	}
 
-	axp_batt->batt_chrg_i = devm_iio_channel_get(&pdev->dev,
-							"batt_chrg_i");
+	axp_batt->batt_chrg_i = devm_iio_channel_get(&pdev->dev, "batt_chrg_i");
 	if (IS_ERR(axp_batt->batt_chrg_i)) {
 		if (PTR_ERR(axp_batt->batt_chrg_i) == -ENODEV)
 			return -EPROBE_DEFER;
@@ -959,8 +1047,7 @@ static void axp209_set_battery_info(struct platform_device *pdev,
 	int ccc = info->constant_charge_current_max_ua;
 
 	if (vmin > 0 && axp20x_set_voltage_min_design(axp_batt, vmin))
-		dev_err(&pdev->dev,
-			"couldn't set voltage_min_design\n");
+		dev_err(&pdev->dev, "couldn't set voltage_min_design\n");
 
 	/* Set max to unverified value to be able to set CCC */
 	axp_batt->max_ccc = ccc;
@@ -984,19 +1071,16 @@ static void axp717_set_battery_info(struct platform_device *pdev,
 	int val;
 
 	if (vmin > 0 && axp717_set_voltage_min_design(axp_batt, vmin))
-		dev_err(&pdev->dev,
-			"couldn't set voltage_min_design\n");
+		dev_err(&pdev->dev, "couldn't set voltage_min_design\n");
 
 	if (vmax > 0 && axp717_battery_set_max_voltage(axp_batt, vmax))
-		dev_err(&pdev->dev,
-			"couldn't set voltage_max_design\n");
+		dev_err(&pdev->dev, "couldn't set voltage_max_design\n");
 
 	axp717_get_constant_charge_current(axp_batt, &val);
 	axp_batt->max_ccc = ccc;
 	if (ccc <= 0 || axp717_set_constant_charge_current(axp_batt, ccc)) {
 		dev_err(&pdev->dev,
-			"couldn't set ccc from DT: current ccc is %d\n",
-			val);
+			"couldn't set ccc from DT: current ccc is %d\n", val);
 	}
 }
 
@@ -1054,16 +1138,20 @@ static const struct of_device_id axp20x_battery_ps_id[] = {
 	{
 		.compatible = "x-powers,axp209-battery-power-supply",
 		.data = (void *)&axp209_data,
-	}, {
+	},
+	{
 		.compatible = "x-powers,axp221-battery-power-supply",
 		.data = (void *)&axp221_data,
-	}, {
+	},
+	{
 		.compatible = "x-powers,axp717-battery-power-supply",
 		.data = (void *)&axp717_data,
-	}, {
+	},
+	{
 		.compatible = "x-powers,axp813-battery-power-supply",
 		.data = (void *)&axp813_data,
-	}, { /* sentinel */ },
+	},
+	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, axp20x_battery_ps_id);
 
@@ -1078,8 +1166,8 @@ static int axp20x_power_probe(struct platform_device *pdev)
 	if (!of_device_is_available(pdev->dev.of_node))
 		return -ENODEV;
 
-	axp20x_batt = devm_kzalloc(&pdev->dev, sizeof(*axp20x_batt),
-				   GFP_KERNEL);
+	axp20x_batt =
+		devm_kzalloc(&pdev->dev, sizeof(*axp20x_batt), GFP_KERNEL);
 	if (!axp20x_batt)
 		return -ENOMEM;
 
@@ -1097,9 +1185,8 @@ static int axp20x_power_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	axp20x_batt->batt = devm_power_supply_register(&pdev->dev,
-						       axp20x_batt->data->bat_ps_desc,
-						       &psy_cfg);
+	axp20x_batt->batt = devm_power_supply_register(
+		&pdev->dev, axp20x_batt->data->bat_ps_desc, &psy_cfg);
 	if (IS_ERR(axp20x_batt->batt)) {
 		dev_err(&pdev->dev, "failed to register power supply: %ld\n",
 			PTR_ERR(axp20x_batt->batt));
@@ -1109,6 +1196,29 @@ static int axp20x_power_probe(struct platform_device *pdev)
 	if (!power_supply_get_battery_info(axp20x_batt->batt, &info)) {
 		axp20x_batt->data->set_bat_info(pdev, axp20x_batt, info);
 		power_supply_put_battery_info(axp20x_batt->batt, info);
+		axp20x_batt->energy_full_design = info->energy_full_design_uwh;
+
+		int cfd = info->charge_full_design_uah;
+
+		// tell pmic about our battery
+		if (cfd) {
+			// [14:8], [7:0], cfd = Value * 1.456mAh
+			cfd = cfd / 1456;
+			regmap_update_bits(axp20x_batt->regmap,
+					   AXP288_FG_DES_CAP0_REG, 0xff,
+					   cfd & 0xff);
+			regmap_update_bits(axp20x_batt->regmap,
+					   AXP288_FG_DES_CAP1_REG, 0xff,
+					   BIT(7) | ((cfd >> 8) & 0xff));
+		} else {
+			dev_warn(axp20x_batt->dev,
+				 "charge full design is not set");
+		}
+	} else {
+		axp20x_batt->energy_full_design = 8000000;
+		dev_warn(axp20x_batt->dev,
+			 "energy full design is not set, default to %d\n",
+			 axp20x_batt->energy_full_design);
 	}
 
 	/*
@@ -1117,6 +1227,12 @@ static int axp20x_power_probe(struct platform_device *pdev)
 	 */
 	axp20x_get_constant_charge_current(axp20x_batt, &axp20x_batt->max_ccc);
 
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_VBUS_IPSOUT_MGMT, 0x03, 0x03);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_OFF_CTRL, 0x08, 0x08);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_CHRG_CTRL2, 0x30, 0x20);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_PEK_KEY, 0x0f, 0x0b);
+	regmap_update_bits(axp20x_batt->regmap, AXP20X_GPIO0_CTRL, 0x07, 0x00);
+
 	return 0;
 }
 
-- 
2.49.0

